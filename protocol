Структура работы программы:
	Процесс запускает у себя два потока
	Один поток на каждой из 5 итераций получает список из 200 заданий. Каждое задание из себя представляет 
  выполнение в цикле какого-то тратящего время действия. Количество повторений цикла вычисляется на каждой итерации 
  и на каждом процессе следующим образом:
taskList[i].repeatNum = |100-i%200| * |rank-(iterCounter%size)| * L,  
где 	i=rank*200..(rank + 1)*200-1 - номер задания
	rank - номер MPI-процесса
	size - количество MPI-процессов
	iterCounter - текущая итерация
	L - коэффициент;
Когда свои задания выполнены, поток запрашивает по одному заданию от других процессов.
В случае получения заданий их выполняет и запрашивает повторно. 
Иначе ожидает, когда остальные процессы закончат итерацию.
Другой поток в цикле выполняет вызов MPI_Recv, где в качестве источника указана константа MPI_ANY_SOURCE (получение от любого процесса). 
Номер процесса-источника можно извлечь из переменной типа MPI_STATUS, которая передается в MPI_Recv последним аргументом. 
MPI_Recv получает целое число, по которому определяет, что нужно делать.
Общение между процессами происходит с использование int flag, где flag принимает значения:
0 - возвращается, если у процесса нет свободных заданий.
1 - возвращается, если у процесса есть свободные задания.
2 - данное число отправляют другие процессы.
Происходит проверка, есть ли свободные задания. 
Если есть, то отправляются сообщение о наличии и последнее задание в списке.(flag = 1)
Если нет, то отправляется сообщение о том, что заданий нет.(flag = 0)
3 - данное число поток отправляет другому потоку своего процесса.
Это говорит о том что абсолютно все задания закончились.
Текущиц поток завершает свое выполнение.
